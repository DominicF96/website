import { locales } from "@/i18n.config";
import fs from "fs";
import path from "path";
import { DatedCaseStudyMetadata } from "@/types/case_study.types";
import {
  getMetadataFromFile,
  generateHash,
  getContentSubdirectories,
} from "../utils/index.utils";

type PreviousIndex = Record<string, Partial<DatedCaseStudyMetadata>>;

function generateCaseStudiesIndex(
  locale: string,
  previousIndex: PreviousIndex = {}
): DatedCaseStudyMetadata[] {
  const caseStudyDir = path.join(
    process.cwd(),
    `content/${locale}/case_studies`
  );
  if (!fs.existsSync(caseStudyDir)) {
    console.error(`Directory not found: ${caseStudyDir}`);
    return [];
  }

  const subdirectories = getContentSubdirectories(caseStudyDir);

  return subdirectories
    .map((subdir) => {
      const pagePath = path.join(caseStudyDir, subdir, "page.mdx");
      console.log(`Processing page: ${pagePath}`);
      if (fs.existsSync(pagePath)) {
        const metadata = getMetadataFromFile(pagePath);
        if (metadata) {
          const hash = generateHash(metadata);
          const previousEntry = previousIndex[metadata.id] || {};
          const lastUpdated =
            hash !== previousEntry.hash
              ? new Date().toISOString().split("T")[0]
              : previousEntry.last_updated ||
              new Date().toISOString().split("T")[0];

          return {
            id: metadata.id,
            title: metadata.title,
            date: metadata.date,
            role: metadata.role,
            description: metadata.description,
            url: metadata.url,
            score: metadata.score,
            hash,
            last_updated: lastUpdated,
          };
        }
      }
      return null;
    })
    .filter((caseStudy): caseStudy is NonNullable<typeof caseStudy> =>
      caseStudy !== null && caseStudy.date !== undefined && caseStudy.id !== undefined
    );
}

console.log("Starting case study index generation...");

locales.forEach((locale) => {
  console.log(`Processing locale: ${locale}...`);

  const previousIndexPath = path.join(
    process.cwd(),
    `app/${locale}/case_study/case_study.i18n.ts`
  );

  let previousIndex: PreviousIndex = {};
  if (fs.existsSync(previousIndexPath)) {
    console.log(`Found previous index file for locale: ${locale}`);
    try {
      const previousContent = JSON.parse(
        fs.readFileSync(previousIndexPath, "utf-8")
      );
      previousIndex = (previousContent[locale] || []).reduce(
        (acc: PreviousIndex, caseStudy: DatedCaseStudyMetadata) => {
          acc[caseStudy.id] = caseStudy;
          return acc;
        },
        {}
      );
    } catch (error) {
      console.error(
        `Failed to load previous index for locale ${locale}...`,
        error
      );
    }
  }

  console.log(`Generating case study index for locale: ${locale}`);
  const caseStudyIndex = generateCaseStudiesIndex(locale, previousIndex);

  // Write to content/${locale}/case_study/index.ts
  const outputFilePath = path.join(
    process.cwd(),
    `content/${locale}/case_studies/index.ts`
  );
  const fileContent = `// This file is generated by case-study-index.script.ts. Do not edit manually.\nimport { DatedCaseStudyMetadata } from \"@/types/case_study.types\";\n\nconst data: DatedCaseStudyMetadata[] = ${JSON.stringify(
    caseStudyIndex,
    null,
    2
  )};\n\nexport default data;\n`;
  console.log(`Writing output file to: ${outputFilePath}`);
  fs.writeFileSync(outputFilePath, fileContent);
});

console.log("Case study index generation completed.");
